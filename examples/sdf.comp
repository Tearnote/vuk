#version 450
#pragma shader_stage(compute)

#extension GL_KHR_shader_subgroup_ballot: enable

//SDF meatballs
// SDF2DC

#define WG_SIZE 200
layout(local_size_x = WG_SIZE) in;

#define FLT_EPS 1E-5

layout(push_constant) uniform pcs {
	vec3 voxbounds_min;
	float dx1;
	vec3 vox_size;
	float dx2;
};

float sdSphere(vec3 p, float s){
  return length(p)-s;
}

float opSmoothUnion(float d1, float d2, float k){
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h); 
}

float eval(vec3 p) {
	float sph1 = sdSphere(p - vec3(dx1,0,0), 1);
	float sph2 = sdSphere(p - vec3(dx2,0,0), 0.75);
	return opSmoothUnion(sph1, sph2, 1);
}

vec3 approximate_normal(vec3 p){
	return vec3(0);
}

layout(binding = 0) restrict buffer verts {
	float vertices[];
};

layout(binding = 1) restrict buffer inds {
	uint indices[];
};

layout(binding = 2) coherent restrict buffer cmd {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int vertexOffset;
	uint firstInstance;
};

shared uint needed_vertices[(WG_SIZE + 1) * 4]; // in our line + [-y -z, -y z, y -z]
shared uint local_index_count;
shared uint req_verts;

shared uint vert_idx;
shared uint ind_idx;

uvec3 block_size;
uvec3 block_corner;

uint linear_index(uvec3 id){
	uvec3 mp = gl_NumWorkGroups * gl_WorkGroupSize;
	return id.z * mp.y * mp.x + id.y * mp.x + id.x * 1;
}

// id.xyz > 0 !
uint local_index(uvec3 gid){
	uvec3 id = gid - block_corner;
	return id.z * block_size.y * block_size.x + id.y * block_size.x + id.x;
}

uvec3 to_lid(uint local_index){
	uint z = local_index / (block_size.y * block_size.x);
	uint m1 = local_index % (block_size.y * block_size.x);
	uint y = m1 / block_size.x;
	uint x = m1 % block_size.x;
	return uvec3(x,y,z);
}

uvec3 to_gid(uint local_index){
	uvec3 lid = to_lid(local_index);
	return lid + block_corner;
}

vec3 to_coord(uint local_index){
	return to_gid(local_index)*vox_size + voxbounds_min;
}

void add_vertex(uint idx, uvec3 gid){
	vec3 corner = gid*vox_size + voxbounds_min;
	vec3 center = corner + 0.5*vox_size;
	vec3 vtx = center;
	vertices[idx * 3 + 0] = vtx.x;
	vertices[idx * 3 + 1] = vtx.y;
	vertices[idx * 3 + 2] = vtx.z;
}

void add_vertex_trilinear(uint idx, uvec3 gid){
	float v[2][2][2];
	vec3 corner = gid*vox_size + voxbounds_min;
	vec3 delta = uvec3(1,1,1)*vox_size;
	// evaluate SDF at corners
	for(uint i = 0; i < 2; i++){
		for(uint j = 0; j < 2; j++){
			for(uint k = 0; k < 2; k++){
				vec3 pt = corner + uvec3(i,j,k) * delta;
				v[i][j][k] = eval(pt);
			}
		}
	}
	vec3 p_sum = vec3(0);//corner + 0.5*vox_size;
	uint p_count = 0;
	for(uint dx = 0; dx < 2; dx++){
		for(uint dy = 0; dy < 2; dy++){
			float v0 = v[dx][dy][0];
			float v1 = v[dx][dy][1];
			float fac = (0-v0)/(v1-v0);
			if((v0 > FLT_EPS) == (v1 < FLT_EPS)){
				vec3 p = corner + vec3(dx, dy, fac) * delta;
				p_sum += p;
				p_count++;
			}
		}
	}
	for(uint dx = 0; dx < 2; dx++){
		for(uint dz = 0; dz < 2; dz++){
			float v0 = v[dx][0][dz];
			float v1 = v[dx][1][dz];
			float fac = (0-v0)/(v1-v0);
			if((v0 > FLT_EPS) == (v1 < FLT_EPS)){
				vec3 p = corner + vec3(dx, fac, dz) * delta;
				p_sum += p;
				p_count++;
			}
		}
	}
	for(uint dy = 0; dy < 2; dy++){
		for(uint dz = 0; dz < 2; dz++){
			float v0 = v[0][dy][dz];
			float v1 = v[1][dy][dz];
			float fac = (0-v0)/(v1-v0);
			if((v0 > FLT_EPS) == (v1 < FLT_EPS)){
				vec3 p = corner + vec3(fac, dy, dz) * delta;
				p_sum += p;
				p_count++;
			}
		}
	}
	vec3 vtx = p_sum / p_count;
	vertices[idx * 3 + 0] = vtx.x;
	vertices[idx * 3 + 1] = vtx.y;
	vertices[idx * 3 + 2] = vtx.z;
}

uint local_quads[3];
uint n_local_quad_inds = 0;

void append_quad(uint type, uvec4 inds, bool swap){
	uint dst = n_local_quad_inds;
	if(swap){
		inds = inds.wzyx; // flip
	}
	local_quads[dst] = type;
	
	atomicAdd(needed_vertices[inds[0]], 1);
	atomicAdd(needed_vertices[inds[1]], 1);
	atomicAdd(needed_vertices[inds[2]], 1);
	atomicAdd(needed_vertices[inds[3]], 1);
	n_local_quad_inds += 1;
}

void main(){
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;
	uint z = gl_GlobalInvocationID.z;
	for(uint i = gl_LocalInvocationIndex; i < ((WG_SIZE + 1) * 4); i += WG_SIZE){
		needed_vertices[i] = 0;
	}
	if(subgroupElect()){
		block_corner = gl_WorkGroupID * gl_WorkGroupSize;
		block_size = gl_WorkGroupSize;
		if(block_corner.x > 0){
			block_size.x++;
			block_corner.x--;
		}
		if(block_corner.y > 0){
			block_size.y++;
			block_corner.y--;
		}
		if(block_corner.z > 0){
			block_size.z++;
			block_corner.z--;
		}
		atomicExchange(req_verts, 0);
		atomicExchange(local_index_count, 0);
	}
	barrier();
	// this really helps VGPR count
	block_size = subgroupBroadcast(block_size, 0);
	block_corner = subgroupBroadcast(block_corner, 0);
	/*block_size = block_size_sh;
	block_corner = block_corner_sh;*/
	/*uint loid = local_index(uvec3(x,y,z));
	uvec3 lid = to_lid(loid);
	uvec3 gid = to_gid(loid);
	indices[3*lin_index+0] = gid.x;
	indices[3*lin_index+1] = gid.y;
	indices[3*lin_index+2] = gid.z;*/
	/*indices[lin_index] = loid;
	return;*/
	vec3 corner = gl_GlobalInvocationID*vox_size + voxbounds_min;

	bool solid1 = eval(corner) > FLT_EPS;
	if(x > 0 && y > 0){
		bool solid2 = eval(corner + vec3(0,0,vox_size.z)) < FLT_EPS;
		if(solid1 == solid2){
			append_quad(0, uvec4(
				local_index(uvec3(x - 1, y - 1, z)),
				local_index(uvec3(x - 0, y - 1, z)),
				local_index(uvec3(x - 0, y - 0, z)),
				local_index(uvec3(x - 1, y - 0, z))
			), !solid2);
		}
	}
	if(x > 0 && z > 0){
		bool solid2 = eval(corner + vec3(0,vox_size.y,0)) < FLT_EPS;
		if(solid1 == solid2){
			append_quad(1, uvec4(
				local_index(uvec3(x - 1, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 0)),
				local_index(uvec3(x - 1, y, z - 0))
			), !solid2);
		}
	}
	
	if(y > 0 && z > 0){
		bool solid2 = eval(corner + vec3(vox_size.x,0,0)) < FLT_EPS;
		if(solid1 == solid2){
			append_quad(2, uvec4(
				local_index(uvec3(x, y - 1, z - 1)),
				local_index(uvec3(x, y - 0, z - 1)),
				local_index(uvec3(x, y - 0, z - 0)),
				local_index(uvec3(x, y - 1, z - 0))
			), !solid2);
		}
	}
	
	//barrier(); // SG finish
	atomicAdd(local_index_count, n_local_quad_inds);
	barrier();
	//memoryBarrierShared();
	// write out vertices, remember the mapping
	for(uint i = gl_LocalInvocationIndex; i < ((WG_SIZE + 1) * 4); i += WG_SIZE){
		if(needed_vertices[i] > 0){
			atomicAdd(req_verts, 1);
		}
	}
	barrier();
	//memoryBarrierShared();
	if(gl_LocalInvocationIndex == 0){
		vert_idx = atomicAdd(firstInstance, req_verts * 3); // reserve space in vtx buffer
		ind_idx = atomicAdd(indexCount, local_index_count * 6); // reserve space in the idx buffer
	}
	barrier();
	//memoryBarrierShared();
	for(uint i = gl_LocalInvocationIndex; i < ((WG_SIZE + 1) * 4); i += WG_SIZE){
		if(needed_vertices[i] > 0){
			uint vidx = atomicAdd(vert_idx, 1);
			add_vertex_trilinear(vidx, to_gid(i));
			needed_vertices[i] = vidx;
		}
		//memoryBarrierShared();
	}
	barrier();
	//memoryBarrierShared();
	// write out indices, remap as we go
	uint idx = atomicAdd(ind_idx, n_local_quad_inds * 6);
	for(uint i = 0; i < n_local_quad_inds; i++){
		uvec4 quad;
		if(local_quads[i] == 0){
			quad = uvec4(local_index(uvec3(x - 1, y - 1, z)),
				local_index(uvec3(x - 0, y - 1, z)),
				local_index(uvec3(x - 0, y - 0, z)),
				local_index(uvec3(x - 1, y - 0, z)));
		} else if (local_quads[i] == 1){
			quad = uvec4(
				local_index(uvec3(x - 1, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 0)),
				local_index(uvec3(x - 1, y, z - 0)));
		} else if (local_quads[i] == 2){
			quad = uvec4(
				local_index(uvec3(x, y - 1, z - 1)),
				local_index(uvec3(x, y - 0, z - 1)),
				local_index(uvec3(x, y - 0, z - 0)),
				local_index(uvec3(x, y - 1, z - 0)));
		}
		indices[idx + 6*i + 0] = needed_vertices[quad[0]];
		indices[idx + 6*i + 1] = needed_vertices[quad[1]];
		indices[idx + 6*i + 2] = needed_vertices[quad[2]];
		indices[idx + 6*i + 3] = needed_vertices[quad[0]];
		indices[idx + 6*i + 4] = needed_vertices[quad[2]];
		indices[idx + 6*i + 5] = needed_vertices[quad[3]];
	}
}