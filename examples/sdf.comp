#version 450
#pragma shader_stage(compute)

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_EXT_control_flow_attributes: enable
#extension GL_EXT_subgroupuniform_qualifier : enable

//SDF meatballs
// SDF2DC

#define WG_SIZE 200
layout(local_size_x = WG_SIZE) in;

#define FLT_EPS 1E-5

layout(push_constant) uniform pcs {
	vec3 voxbounds_min;
	float dx1;
	vec3 vox_size;
	float dx2;
	uint vtx_plc_method;
};

float sdSphere(vec3 p, float s){
  return length(p)-s;
}

float opSmoothUnion(float d1, float d2, float k){
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h); 
}

vec3 opColorSmoothUnion(vec3 c1, vec3 c2, float d1, float d2, float k){
	float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);
	h = smoothstep(0.1, 0.9, h);
	return mix(c2, c1, h);
}

float eval(vec3 p) {
	float sph1 = sdSphere(p - vec3(dx1,0,0), 1);
	float sph2 = sdSphere(p - vec3(dx2,0,0), 0.75);
	return opSmoothUnion(sph1, sph2, 1);
}

vec3 eval_color(vec3 p) {
	vec3 c1 = vec3(1,0,0);
	vec3 c2 = vec3(0,0,1);
	float sph1 = sdSphere(p - vec3(dx1,0,0), 1);
	float sph2 = sdSphere(p - vec3(dx2,0,0), 0.75);
	float h = clamp(0.5 + 0.5*(sph2-sph1)/1, 0.0, 1.0);
	h = smoothstep(0.1, 0.9, h);
	return mix(c2, c1, h);
}

layout(binding = 0) restrict buffer verts {
	float vertices[];
};

layout(binding = 1) restrict buffer inds {
	uint indices[];
};

#define STACK_DEPTH 3

#define SDF_CMD_END 0
#define SDF_CMD_TRANSFORM 1
#define SDF_CMD_SPHERE 2
#define SDF_CMD_SMOOTH_COMBINE 3

layout(binding = 2) restrict buffer cmdin {
	uint cmdstream[];
};

// TODO: scalarization didn't help?
// scalarize cmd decoding
void eval_vm(vec3 p, out float pos, out vec3 color){
	float stack[STACK_DEPTH];
	vec3 color_stack[STACK_DEPTH];
	uint sp = 0;
	uint pc = 0; // program counter (dwords), all instr/data multiple of dwords
	mat4 inv_transform = mat4(1.f);
	uint cmd;
	//if(subgroupElect())
		cmd = cmdstream[pc];
	//cmd = subgroupBroadcast(cmd, 0);
	for(int i = 0; i < 128 && cmd != SDF_CMD_END; i++){
		//if(subgroupElect())
			pc++;
		//pc = subgroupBroadcast(pc, 0);
		switch(cmd){
			case SDF_CMD_TRANSFORM:
				//if(subgroupElect()){
				inv_transform = mat4(uintBitsToFloat(cmdstream[pc]),uintBitsToFloat(cmdstream[pc+1]),uintBitsToFloat(cmdstream[pc+2]),uintBitsToFloat(cmdstream[pc+3]), uintBitsToFloat(cmdstream[pc+4]),uintBitsToFloat(cmdstream[pc+5]),uintBitsToFloat(cmdstream[pc+6]),uintBitsToFloat(cmdstream[pc+7]),uintBitsToFloat(cmdstream[pc+8]),uintBitsToFloat(cmdstream[pc+9]),uintBitsToFloat(cmdstream[pc+10]),uintBitsToFloat(cmdstream[pc+11]),uintBitsToFloat(cmdstream[pc+12]),uintBitsToFloat(cmdstream[pc+13]),uintBitsToFloat(cmdstream[pc+14]),uintBitsToFloat(cmdstream[pc+15]));
				//}
				/*inv_transform[0] = subgroupBroadcast(inv_transform[0], 0);
				inv_transform[1] = subgroupBroadcast(inv_transform[1], 0);
				inv_transform[2] = subgroupBroadcast(inv_transform[2], 0);
				inv_transform[3] = subgroupBroadcast(inv_transform[3], 0);*/
				//if(subgroupElect())
					pc+=16;
				//pc = subgroupBroadcast(pc, 0);
				break;
			case SDF_CMD_SPHERE:
				float radius;
				//if(subgroupElect())
					radius = uintBitsToFloat(cmdstream[pc]);
				//radius = subgroupBroadcast(radius, 0);
				stack[sp] = sdSphere(vec3(inv_transform * vec4(p, 1.0)), radius); // push sphere eval to stack
				//if(subgroupElect())
					color_stack[sp] = vec3(uintBitsToFloat(cmdstream[pc+1]), uintBitsToFloat(cmdstream[pc+2]), uintBitsToFloat(cmdstream[pc+3]));
				//color_stack[sp] = subgroupBroadcast(color_stack[sp], 0);
				//if(subgroupElect())
					sp++;
				//sp = subgroupBroadcast(sp, 0);
				//if(subgroupElect())
					inv_transform = mat4(1.0); // consume transform
				/*inv_transform[0] = subgroupBroadcast(inv_transform[0], 0);
				inv_transform[1] = subgroupBroadcast(inv_transform[1], 0);
				inv_transform[2] = subgroupBroadcast(inv_transform[2], 0);
				inv_transform[3] = subgroupBroadcast(inv_transform[3], 0);*/
				//if(subgroupElect())
					pc+=4;
				//pc = subgroupBroadcast(pc, 0);
				break;
			case SDF_CMD_SMOOTH_COMBINE:
				float k = uintBitsToFloat(cmdstream[pc]);
				color_stack[sp-2] = opColorSmoothUnion(color_stack[sp-2], color_stack[sp-1], stack[sp-2], stack[sp-1], k); // pop 1, set
				stack[sp-2] = opSmoothUnion(stack[sp-2], stack[sp-1], k); // pop 1, set
				//if(subgroupElect())
					sp--;
				//sp = subgroupBroadcast(sp, 0);
				//if(subgroupElect())
					pc++;
				//pc = subgroupBroadcast(pc, 0);
				break;
		}
		//subgroupBarrier();
		//if(subgroupElect())
			cmd = cmdstream[pc];
		//cmd = subgroupBroadcast(cmd, 0);
	}
	pos = stack[0]; // top of stack must be final SDF
	color = color_stack[0];
}

layout(binding = 3) coherent restrict buffer cmdout {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int vertexOffset;
	uint firstInstance;
};

shared uint needed_vertices[(WG_SIZE + 1) * 4]; // in our line + [-y -z, -y z, y -z]
shared uint local_index_count;
shared uint req_verts;

shared uint vert_idx;
shared uint ind_idx;

shared bool abort;

uvec3 block_size;
uvec3 block_corner;

uint linear_index(uvec3 id){
	uvec3 mp = gl_NumWorkGroups * gl_WorkGroupSize;
	return id.z * mp.y * mp.x + id.y * mp.x + id.x * 1;
}

// id.xyz > 0 !
uint local_index(uvec3 gid){
	uvec3 id = gid - block_corner;
	return id.z * block_size.y * block_size.x + id.y * block_size.x + id.x;
}

uvec3 to_lid(uint local_index){
	uint z = local_index / (block_size.y * block_size.x);
	uint m1 = local_index % (block_size.y * block_size.x);
	uint y = m1 / block_size.x;
	uint x = m1 % block_size.x;
	return uvec3(x,y,z);
}

uvec3 to_gid(uint local_index){
	uvec3 lid = to_lid(local_index);
	return lid + block_corner;
}

vec3 to_coord(uint local_index){
	return to_gid(local_index)*vox_size + voxbounds_min;
}

void add_vertex(uint idx, uvec3 gid){
	vec3 corner = gid*vox_size + voxbounds_min;
	vec3 center = corner + 0.5*vox_size;
	vec3 vtx = center;
	float _;
	vec3 col;
	eval_vm(vtx, _, col);
	vertices[idx * 6 + 0] = vtx.x;
	vertices[idx * 6 + 1] = vtx.y;
	vertices[idx * 6 + 2] = vtx.z;
	vertices[idx * 6 + 3] = col.x;
	vertices[idx * 6 + 4] = col.y;
	vertices[idx * 6 + 5] = col.z;
}

void add_vertex_trilinear(uint idx, uvec3 gid){
	float v[2][2][2];
	vec3 corner = gid*vox_size + voxbounds_min;
	vec3 delta = uvec3(1,1,1)*vox_size;
	// evaluate SDF at corners
	[[unroll]]
	for(uint i = 0; i < 2; i++){
		[[unroll]]
		for(uint j = 0; j < 2; j++){
			[[unroll]]
			for(uint k = 0; k < 2; k++){
				vec3 pt = corner + uvec3(i,j,k) * delta;
				vec3 _;
				eval_vm(pt, v[i][j][k], _);
			}
		}
	}
	vec3 p_sum = vec3(0);//corner + 0.5*vox_size;
	uint p_count = 0;
	for(uint dx = 0; dx < 2; dx++){
		for(uint dy = 0; dy < 2; dy++){
			float v0 = v[dx][dy][0];
			float v1 = v[dx][dy][1];
			float fac = (0-v0)/(v1-v0);
			if((v0 > FLT_EPS) == (v1 < FLT_EPS)){
				vec3 p = corner + vec3(dx, dy, fac) * delta;
				p_sum += p;
				p_count++;
			}
		}
	}
	for(uint dx = 0; dx < 2; dx++){
		for(uint dz = 0; dz < 2; dz++){
			float v0 = v[dx][0][dz];
			float v1 = v[dx][1][dz];
			float fac = (0-v0)/(v1-v0);
			if((v0 > FLT_EPS) == (v1 < FLT_EPS)){
				vec3 p = corner + vec3(dx, fac, dz) * delta;
				p_sum += p;
				p_count++;
			}
		}
	}
	for(uint dy = 0; dy < 2; dy++){
		for(uint dz = 0; dz < 2; dz++){
			float v0 = v[0][dy][dz];
			float v1 = v[1][dy][dz];
			float fac = (0-v0)/(v1-v0);
			if((v0 > FLT_EPS) == (v1 < FLT_EPS)){
				vec3 p = corner + vec3(fac, dy, dz) * delta;
				p_sum += p;
				p_count++;
			}
		}
	}
	vec3 vtx = p_sum / p_count;
	float _;
	vec3 col;
	eval_vm(vtx, _, col);
	vertices[idx * 6 + 0] = vtx.x;
	vertices[idx * 6 + 1] = vtx.y;
	vertices[idx * 6 + 2] = vtx.z;
	vertices[idx * 6 + 3] = col.x;
	vertices[idx * 6 + 4] = col.y;
	vertices[idx * 6 + 5] = col.z;
}

uint local_quads[3];
uint n_local_quad_inds = 0;

void append_quad(uint type, uvec4 inds, bool swap){
	uint dst = n_local_quad_inds;
	if(swap){
		inds = inds.wzyx; // flip
	}
	local_quads[dst] = type;
	
	atomicAdd(needed_vertices[inds[0]], 1);
	atomicAdd(needed_vertices[inds[1]], 1);
	atomicAdd(needed_vertices[inds[2]], 1);
	atomicAdd(needed_vertices[inds[3]], 1);
	n_local_quad_inds += 1;
}

void main(){
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;
	uint z = gl_GlobalInvocationID.z;
	for(uint i = gl_LocalInvocationIndex; i < ((WG_SIZE + 1) * 4); i += WG_SIZE){
		needed_vertices[i] = 0;
	}
	if(subgroupElect()){
		block_corner = gl_WorkGroupID * gl_WorkGroupSize;
		block_size = gl_WorkGroupSize;
		if(block_corner.x > 0){
			block_size.x++;
			block_corner.x--;
		}
		if(block_corner.y > 0){
			block_size.y++;
			block_corner.y--;
		}
		if(block_corner.z > 0){
			block_size.z++;
			block_corner.z--;
		}
		atomicExchange(req_verts, 0);
		atomicExchange(local_index_count, 0);
	}
	barrier();
	// this really helps VGPR count
	block_size = subgroupBroadcast(block_size, 0);
	block_corner = subgroupBroadcast(block_corner, 0);
	/*block_size = block_size_sh;
	block_corner = block_corner_sh;*/
	/*uint loid = local_index(uvec3(x,y,z));
	uvec3 lid = to_lid(loid);
	uvec3 gid = to_gid(loid);
	indices[3*lin_index+0] = gid.x;
	indices[3*lin_index+1] = gid.y;
	indices[3*lin_index+2] = gid.z;*/
	/*indices[lin_index] = loid;
	return;*/
	vec3 corner = gl_GlobalInvocationID*vox_size + voxbounds_min;
	vec3 _;
	float pos;
	eval_vm(corner, pos, _);
	bool solid1 = pos > FLT_EPS;
	
	eval_vm(corner + vec3(0,0,vox_size.z), pos, _);
	if(x > 0 && y > 0){
		bool solid2 = pos < FLT_EPS;
		if(solid1 == solid2){
			append_quad(0, uvec4(
				local_index(uvec3(x - 1, y - 1, z)),
				local_index(uvec3(x - 0, y - 1, z)),
				local_index(uvec3(x - 0, y - 0, z)),
				local_index(uvec3(x - 1, y - 0, z))
			), !solid2);
		}
	}
	
	eval_vm(corner + vec3(0,vox_size.y,0), pos, _);
	if(x > 0 && z > 0){
		bool solid2 = pos < FLT_EPS;
		if(solid1 == solid2){
			append_quad(1, uvec4(
				local_index(uvec3(x - 1, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 0)),
				local_index(uvec3(x - 1, y, z - 0))
			), !solid2);
		}
	}
	
	eval_vm(corner + vec3(vox_size.x,0,0), pos, _);
	if(y > 0 && z > 0){
		bool solid2 = pos < FLT_EPS;
		if(solid1 == solid2){
			append_quad(2, uvec4(
				local_index(uvec3(x, y - 1, z - 1)),
				local_index(uvec3(x, y - 0, z - 1)),
				local_index(uvec3(x, y - 0, z - 0)),
				local_index(uvec3(x, y - 1, z - 0))
			), !solid2);
		}
	}
	
	//barrier(); // SG finish
	atomicAdd(local_index_count, n_local_quad_inds);
	barrier();
	//memoryBarrierShared();
	// write out vertices, remember the mapping
	for(uint i = gl_LocalInvocationIndex; i < ((WG_SIZE + 1) * 4); i += WG_SIZE){
		if(needed_vertices[i] > 0){
			atomicAdd(req_verts, 1);
		}
	}
	barrier();
	//memoryBarrierShared();
	if(gl_LocalInvocationIndex == 0){
		abort = (firstInstance * 6 > (vertices.length() - req_verts * 6)) || ((indexCount > (indices.length() - local_index_count*6)));
		if(!abort){
			vert_idx = atomicAdd(firstInstance, req_verts); // reserve space in vtx buffer
			ind_idx = atomicAdd(indexCount, local_index_count * 6); // reserve space in the idx buffer
			abort = abort || (vert_idx * 6 > (vertices.length() - req_verts * 6));
			if(abort){
				for(uint i = 0; i < local_index_count * 6; i++){
					indices[ind_idx + i] = 0;
				}
			}
			abort = abort || ((ind_idx > (indices.length() - local_index_count*6)));
		}
	}
	barrier();
	if(abort)
		return;
	//memoryBarrierShared();
	for(uint i = gl_LocalInvocationIndex; i < ((WG_SIZE + 1) * 4); i += WG_SIZE){
		if(needed_vertices[i] > 0){
			uint vidx = atomicAdd(vert_idx, 1);
			if(vtx_plc_method == 0){
				add_vertex(vidx, to_gid(i));
			} else if (vtx_plc_method == 1){
				add_vertex_trilinear(vidx, to_gid(i));
			}
			needed_vertices[i] = vidx;
		}
		//memoryBarrierShared();
	}
	barrier();
	//memoryBarrierShared();
	// write out indices, remap as we go
	uint idx = atomicAdd(ind_idx, n_local_quad_inds * 6);
	for(uint i = 0; i < n_local_quad_inds; i++){
		uvec4 quad;
		if(local_quads[i] == 0){
			quad = uvec4(local_index(uvec3(x - 1, y - 1, z)),
				local_index(uvec3(x - 0, y - 1, z)),
				local_index(uvec3(x - 0, y - 0, z)),
				local_index(uvec3(x - 1, y - 0, z)));
		} else if (local_quads[i] == 1){
			quad = uvec4(
				local_index(uvec3(x - 1, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 0)),
				local_index(uvec3(x - 1, y, z - 0)));
		} else if (local_quads[i] == 2){
			quad = uvec4(
				local_index(uvec3(x, y - 1, z - 1)),
				local_index(uvec3(x, y - 0, z - 1)),
				local_index(uvec3(x, y - 0, z - 0)),
				local_index(uvec3(x, y - 1, z - 0)));
		}
		indices[idx + 6*i + 0] = needed_vertices[quad[0]];
		indices[idx + 6*i + 1] = needed_vertices[quad[1]];
		indices[idx + 6*i + 2] = needed_vertices[quad[2]];
		indices[idx + 6*i + 3] = needed_vertices[quad[0]];
		indices[idx + 6*i + 4] = needed_vertices[quad[2]];
		indices[idx + 6*i + 5] = needed_vertices[quad[3]];
	}
}