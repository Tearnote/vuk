#version 450
#pragma shader_stage(compute)

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_EXT_control_flow_attributes: enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64:enable

// TODO: corruption with larger size, why?
#define WG_SIZE 64
#define BOX_SIZE 5*5*5
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#define FLT_EPS 1E-5

#define NUM_VERTEX_FLOATS 7

layout(push_constant) uniform pcs {
	vec3 voxbounds_min;
	float dx1;
	vec3 vox_size;
	uint vtx_plc_method;
	vec3 view_vec;
};

float sdSphere(vec3 p, float s){
  return length(p)-s;
}

float opSmoothUnion(float d1, float d2, float k){
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h); 
}

/**

**/

uint opColorSmoothUnion(uint c1, uint c2, float d1, float d2, float k){
	float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);
	h = smoothstep(0.1, 0.9, h);
	return packUnorm4x8(vec4(vec3(mix(unpackUnorm4x8(c2), unpackUnorm4x8(c1), vec4(h))), 1.0));
}

layout(binding = 0) restrict coherent writeonly buffer verts {
	float vertices[];
};

layout(binding = 1) restrict coherent writeonly buffer inds {
	uint indices[];
};

#define STACK_DEPTH 2

#define SDF_CMD_END 0
#define SDF_CMD_TRANSFORM 1
#define SDF_CMD_SPHERE 2
#define SDF_CMD_SMOOTH_COMBINE 3

layout(binding = 2) restrict uniform cmdin {
	uvec4 cmdstream[512];
};

layout(binding = 2) restrict uniform cmdin_mat4 {
	vec4 cmdstream_mat4[512];
};

shared float stack[WG_SIZE][STACK_DEPTH];

void eval_vm(vec3 p, out float pos){
	uint sp = 0;
	uint pc = 0; // program counter (dwords), all instr/data multiple of dwords
	mat4 inv_transform = mat4(1.f);
	uint cmd;

	cmd = cmdstream[pc].x;
	for(int i = 0; i < 256 && cmd != SDF_CMD_END; i++){
		switch(cmd){
			case SDF_CMD_TRANSFORM:
				pc++;
				inv_transform = mat4(cmdstream_mat4[pc], cmdstream_mat4[pc+1], cmdstream_mat4[pc+2], cmdstream_mat4[pc+3]);
				pc+=4;
				break;
			case SDF_CMD_SPHERE:
				float radius = uintBitsToFloat(cmdstream[pc].y);
				stack[gl_LocalInvocationIndex][sp] = sdSphere(vec3(inv_transform * vec4(p, 1.0)), radius); // push sphere eval to stack
				sp++;
				inv_transform = mat4(1.0); // consume transform
				pc+=2;
				break;
			case SDF_CMD_SMOOTH_COMBINE:
				float k = uintBitsToFloat(cmdstream[pc].y);
				stack[gl_LocalInvocationIndex][sp-2] = opSmoothUnion(stack[gl_LocalInvocationIndex][sp-2], stack[gl_LocalInvocationIndex][sp-1], k); // pop 1, set
				sp--;
				pc++;
				break;
		}
		cmd = cmdstream[pc].x;
	}
	pos = stack[gl_LocalInvocationIndex][0]; // top of stack must be final SDF
}

shared uint col_stack[WG_SIZE][STACK_DEPTH];

void eval_vm_c(vec3 p, out float pos, out uint col){
	uint sp = 0;
	uint pc = 0; // program counter (dwords), all instr/data multiple of dwords
	mat4 inv_transform = mat4(1.f);
	uint cmd;

	cmd = cmdstream[pc].x;
	for(int i = 0; i < 256 && cmd != SDF_CMD_END; i++){
		switch(cmd){
			case SDF_CMD_TRANSFORM:
				pc++;
				inv_transform = mat4(cmdstream_mat4[pc], cmdstream_mat4[pc+1], cmdstream_mat4[pc+2], cmdstream_mat4[pc+3]);
				pc+=4;
				break;
			case SDF_CMD_SPHERE:
				float radius = uintBitsToFloat(cmdstream[pc].y);
				stack[gl_LocalInvocationIndex][sp] = sdSphere(vec3(inv_transform * vec4(p, 1.0)), radius); // push sphere eval to stack
				col_stack[gl_LocalInvocationIndex][sp] = packUnorm4x8(vec4(vec3(cmdstream_mat4[pc+1]),1));
				sp++;
				inv_transform = mat4(1.0); // consume transform
				pc+=2;
				break;
			case SDF_CMD_SMOOTH_COMBINE:
				float k = uintBitsToFloat(cmdstream[pc].y);
				col_stack[gl_LocalInvocationIndex][sp-2] = opColorSmoothUnion(col_stack[gl_LocalInvocationIndex][sp-2], col_stack[gl_LocalInvocationIndex][sp-1], stack[gl_LocalInvocationIndex][sp-2], stack[gl_LocalInvocationIndex][sp-1], k); // pop 1, set
				stack[gl_LocalInvocationIndex][sp-2] = opSmoothUnion(stack[gl_LocalInvocationIndex][sp-2], stack[gl_LocalInvocationIndex][sp-1], k); // pop 1, set
				sp--;
				pc++;
				break;
		}
		cmd = cmdstream[pc].x;
	}
	pos = stack[gl_LocalInvocationIndex][0]; // top of stack must be final SDF
	col = col_stack[gl_LocalInvocationIndex][0];
}

layout(binding = 3) coherent restrict buffer cmdout {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int vertexOffset;
	uint firstInstance;
	uint tmpIndex;
};

shared uint needed_vertices[BOX_SIZE]; // in our line + [-y -z, -y z, y -z]
shared uint local_index_count;
shared uint req_verts;

shared uint vert_idx;
shared uint ind_idx;

shared bool abort;

uvec3 block_size;
uvec3 block_corner;

uint linear_index(uvec3 id){
	uvec3 mp = gl_NumWorkGroups * gl_WorkGroupSize;
	return id.z * mp.y * mp.x + id.y * mp.x + id.x * 1;
}

// id.xyz > 0 !
uint local_index(uvec3 gid){
	uvec3 id = gid - block_corner;
	return id.z * block_size.y * block_size.x + id.y * block_size.x + id.x;
}

uvec3 to_lid(uint local_index){
	uint z = local_index / (block_size.y * block_size.x);
	uint m1 = local_index % (block_size.y * block_size.x);
	uint y = m1 / block_size.x;
	uint x = m1 % block_size.x;
	return uvec3(x,y,z);
}

uvec3 to_gid(uint local_index){
	uvec3 lid = to_lid(local_index);
	return lid + block_corner;
}

vec3 to_coord(uint local_index){
	return to_gid(local_index)*vox_size + voxbounds_min;
}

void add_vertex(uint idx, uvec3 gid){
	vec3 corner = gid*vox_size + voxbounds_min;
	vec3 center = corner + 0.5*vox_size;
	vec3 vtx = center;
	float _;
	uint col;
	eval_vm_c(vtx, _, col);
	vertices[idx * NUM_VERTEX_FLOATS + 0] = vtx.x;
	vertices[idx * NUM_VERTEX_FLOATS + 1] = vtx.y;
	vertices[idx * NUM_VERTEX_FLOATS + 2] = vtx.z;
	vertices[idx * NUM_VERTEX_FLOATS + 3] = uintBitsToFloat(col);
	vertices[idx * NUM_VERTEX_FLOATS + 4] = 0;
	vertices[idx * NUM_VERTEX_FLOATS + 5] = 0;
	vertices[idx * NUM_VERTEX_FLOATS + 6] = 0;
}

void add_vertex_trilinear(uint idx, uvec3 gid){
	float v[2][2][2];
	vec3 corner = gid*vox_size + voxbounds_min;
	vec3 delta = uvec3(1,1,1)*vox_size;
	// evaluate SDF at corners
	[[unroll]]
	for(uint i = 0; i < 2; i++){
		[[unroll]]
		for(uint j = 0; j < 2; j++){
			[[unroll]]
			for(uint k = 0; k < 2; k++){
				vec3 pt = corner + uvec3(i,j,k) * delta;
				uint _;
				eval_vm(pt, v[i][j][k]);
			}
		}
	}
	vec3 p_sum = vec3(0);//corner + 0.5*vox_size;
	uint p_count = 0;
	for(uint dx = 0; dx < 2; dx++){
		for(uint dy = 0; dy < 2; dy++){
			float v0 = v[dx][dy][0];
			float v1 = v[dx][dy][1];
			float fac = (0-v0)/(v1-v0);
			uint val = uint((v0 > FLT_EPS) == (v1 < FLT_EPS));
			vec3 p = vec3(dx, dy, fac) * delta;
			p_sum += p * val;
			p_count+=val;
		}
	}
	for(uint dx = 0; dx < 2; dx++){
		for(uint dz = 0; dz < 2; dz++){
			float v0 = v[dx][0][dz];
			float v1 = v[dx][1][dz];
			float fac = (0-v0)/(v1-v0);
			uint val = uint((v0 > FLT_EPS) == (v1 < FLT_EPS));
			vec3 p = vec3(dx, fac, dz) * delta;
			p_sum += p * val;
			p_count+=val;
		}
	}
	for(uint dy = 0; dy < 2; dy++){
		for(uint dz = 0; dz < 2; dz++){
			float v0 = v[0][dy][dz];
			float v1 = v[1][dy][dz];
			float fac = (0-v0)/(v1-v0);
			uint val = uint((v0 > FLT_EPS) == (v1 < FLT_EPS));
			vec3 p = vec3(fac, dy, dz) * delta;
			p_sum += p * val;
			p_count+=val;
		}
	}
	vec3 vtx = corner + p_sum / p_count;
	float _;
	uint col;
	eval_vm_c(vtx, _, col);
	vertices[idx * NUM_VERTEX_FLOATS + 0] = vtx.x;
	vertices[idx * NUM_VERTEX_FLOATS + 1] = vtx.y;
	vertices[idx * NUM_VERTEX_FLOATS + 2] = vtx.z;
	vertices[idx * NUM_VERTEX_FLOATS + 3] = uintBitsToFloat(col);
	vec3 norm = vec3(v[0][0][0] - v[1][0][0], v[0][0][0] - v[0][1][0], v[0][0][0] - v[0][0][1]);
	vertices[idx * NUM_VERTEX_FLOATS + 4] = norm.x;
	vertices[idx * NUM_VERTEX_FLOATS + 5] = norm.y;
	vertices[idx * NUM_VERTEX_FLOATS + 6] = norm.z;
}

void append_quad(uvec4 inds, bool swap){
	atomicExchange(needed_vertices[inds[0]], 1);
	atomicExchange(needed_vertices[inds[1]], 1);
	atomicExchange(needed_vertices[inds[2]], 1);
	atomicExchange(needed_vertices[inds[3]], 1);
}

void main(){
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;
	uint z = gl_GlobalInvocationID.z;
	for(uint i = gl_LocalInvocationIndex; i < BOX_SIZE; i += WG_SIZE){
		needed_vertices[i] = 0;
	}
	if(subgroupElect()){
		block_corner = gl_WorkGroupID * gl_WorkGroupSize;
		block_size = gl_WorkGroupSize;
		if(block_corner.x > 0){
			block_size.x++;
			block_corner.x--;
		}
		if(block_corner.y > 0){
			block_size.y++;
			block_corner.y--;
		}
		if(block_corner.z > 0){
			block_size.z++;
			block_corner.z--;
		}
		atomicExchange(req_verts, 0);
		atomicExchange(local_index_count, 0);
	}
	barrier();
	// this really helps VGPR count
	block_size = subgroupBroadcast(block_size, 0);
	block_corner = subgroupBroadcast(block_corner, 0);

	vec3 corner = gl_GlobalInvocationID*vox_size + voxbounds_min;
	uint _;
	float pos;
	
	eval_vm(corner, pos);
	
	bool lquad[3] = {false, false, false};
	bool solid1 = pos > FLT_EPS;
	
	if(x > 0 && y > 0){
		eval_vm(corner + vec3(0,0,vox_size.z), pos);
		bool solid2 = pos < FLT_EPS;
		if(solid1 == solid2){
			lquad[0] = true;
			append_quad(uvec4(
				local_index(uvec3(x - 1, y - 1, z)),
				local_index(uvec3(x - 0, y - 1, z)),
				local_index(uvec3(x - 0, y - 0, z)),
				local_index(uvec3(x - 1, y - 0, z))
			), !solid2);
		}
	}
	
	if(x > 0 && z > 0){
		eval_vm(corner + vec3(0,vox_size.y,0), pos);
		bool solid2 = pos < FLT_EPS;
		if(solid1 == solid2){
			lquad[1] = true;
			append_quad(uvec4(
				local_index(uvec3(x - 1, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 1)),
				local_index(uvec3(x - 0, y, z - 0)),
				local_index(uvec3(x - 1, y, z - 0))
			), !solid2);
		}
	}
	
	if(y > 0 && z > 0){
		eval_vm(corner + vec3(vox_size.x,0,0), pos);
		bool solid2 = pos < FLT_EPS;
		if(solid1 == solid2){
			lquad[2] = true;
			append_quad(uvec4(
				local_index(uvec3(x, y - 1, z - 1)),
				local_index(uvec3(x, y - 0, z - 1)),
				local_index(uvec3(x, y - 0, z - 0)),
				local_index(uvec3(x, y - 1, z - 0))
			), !solid2);
		}
	}
	
	
	uint n_sg_quad_inds = subgroupBallotBitCount(subgroupBallot(lquad[0])) + subgroupBallotBitCount(subgroupBallot(lquad[1])) + subgroupBallotBitCount(subgroupBallot(lquad[2]));
	if(subgroupElect()){
		atomicAdd(local_index_count, n_sg_quad_inds);
	}
	
	barrier();
	// write out vertices, remember the mapping
	for(uint i = gl_LocalInvocationIndex; i < BOX_SIZE; i += WG_SIZE){
		if(needed_vertices[i] == 1){
			atomicAdd(req_verts, 1);
		}
	}
	barrier();
	
	if(gl_LocalInvocationIndex == 0){
		abort = (firstInstance * NUM_VERTEX_FLOATS > (vertices.length() - req_verts * NUM_VERTEX_FLOATS)) || ((tmpIndex > (indices.length() - local_index_count*6)));
		if(!abort){
			vert_idx = atomicAdd(firstInstance, req_verts); // reserve space in vtx buffer
			ind_idx = atomicAdd(tmpIndex, local_index_count * 6); // reserve space in the idx buffer
			abort = abort || (vert_idx * NUM_VERTEX_FLOATS > (vertices.length() - req_verts * NUM_VERTEX_FLOATS));
			if(abort){
				for(uint i = 0; i < local_index_count * 6; i++){
					indices[ind_idx + i] = 0;
				}
			}
			abort = abort || ((ind_idx > (indices.length() - local_index_count*6)));
		}
	}
	barrier();
	if(abort)
		return;
	for(uint i = gl_LocalInvocationIndex; i < BOX_SIZE; i += WG_SIZE){
		if(needed_vertices[i] == 1){
			uint vidx = atomicAdd(vert_idx, 1);
			if(vtx_plc_method == 0){
				add_vertex(vidx, to_gid(i));
			} else if (vtx_plc_method == 1){
				add_vertex_trilinear(vidx, to_gid(i));
			}
			needed_vertices[i] = vidx;
		}
	}
	barrier();
	// write out indices, remap as we go
	uint n_ids = (uint(lquad[0]) + uint(lquad[1]) + uint(lquad[2]));
	uint idx = atomicAdd(ind_idx, n_ids * 6);
	if(lquad[0]){
		uvec4 quad = uvec4(
			local_index(uvec3(x - 1, y - 1, z)),
			local_index(uvec3(x - 0, y - 1, z)),
			local_index(uvec3(x - 0, y - 0, z)),
			local_index(uvec3(x - 1, y - 0, z)));
		indices[idx + 0] = needed_vertices[quad[0]];
		indices[idx + 1] = needed_vertices[quad[1]];
		indices[idx + 2] = needed_vertices[quad[2]];
		indices[idx + 3] = needed_vertices[quad[0]];
		indices[idx + 4] = needed_vertices[quad[2]];
		indices[idx + 5] = needed_vertices[quad[3]];
		idx += 6;
	} 
	if (lquad[1]){
		uvec4 quad = uvec4(
			local_index(uvec3(x - 1, y, z - 1)),
			local_index(uvec3(x - 0, y, z - 1)),
			local_index(uvec3(x - 0, y, z - 0)),
			local_index(uvec3(x - 1, y, z - 0)));
		indices[idx + 0] = needed_vertices[quad[0]];
		indices[idx + 1] = needed_vertices[quad[1]];
		indices[idx + 2] = needed_vertices[quad[2]];
		indices[idx + 3] = needed_vertices[quad[0]];
		indices[idx + 4] = needed_vertices[quad[2]];
		indices[idx + 5] = needed_vertices[quad[3]];
		idx += 6;
	}
	if (lquad[2]){
		uvec4 quad = uvec4(
			local_index(uvec3(x, y - 1, z - 1)),
			local_index(uvec3(x, y - 0, z - 1)),
			local_index(uvec3(x, y - 0, z - 0)),
			local_index(uvec3(x, y - 1, z - 0)));
		indices[idx + 0] = needed_vertices[quad[0]];
		indices[idx + 1] = needed_vertices[quad[1]];
		indices[idx + 2] = needed_vertices[quad[2]];
		indices[idx + 3] = needed_vertices[quad[0]];
		indices[idx + 4] = needed_vertices[quad[2]];
		indices[idx + 5] = needed_vertices[quad[3]];
	}
	
	if(gl_LocalInvocationIndex == 0){
		atomicAdd(indexCount, local_index_count * 6);
	}
}